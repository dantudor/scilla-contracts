scilla_version 0 import BoolUtils ListUtils IntUtils PairUtils library FungibleToken let one_msg = fun (msg : Message) => let nil_msg = Nil {Message} in Cons {Message} msg nil_msg let two_msgs = fun (msg1 : Message) => fun (msg2 : Message) => let msgs_tmp = one_msg msg2 in Cons {Message} msg1 msgs_tmp type Error = | CodeIsSender | CodeInsufficientFunds | CodeInsufficientAllowance | StagingOwnerValidationFailed | StagingOwnerNotExist let make_error = fun (result : Error) => let result_code = match result with | CodeIsSender => Int32 -1 | CodeInsufficientFunds => Int32 -2 | CodeInsufficientAllowance => Int32 -3 | StagingOwnerValidationFailed => Int32 -4 | StagingOwnerNotExist => Int32 -5 end in { _exception : "Error"; code : result_code } let zero = Uint128 0 let build_pair = fun (from : ByStr20) => fun (to_pair : Pair (ByStr20) (Uint128)) => Pair {(Pair (ByStr20) (Uint128)) ByStr20} to_pair from let list_total = tfun 'A => fun (l : List(Uint128)) => let folder = @list_foldl Uint128 Uint128 in let init = Uint128 0 in let iter = fun (z : Uint128) => fun (h : Uint128) => builtin add h z in folder iter init l let get_val = fun (some_val: Option Uint128) => match some_val with | Some val => val | None => zero end let bool_active = True let bool_inactive = False let zero_address = 0x0000000000000000000000000000000000000000 contract FungibleToken ( initial_owner: ByStr20, name : String, symbol: String, decimals: Uint32, init_supply : Uint128 ) field owner : ByStr20 = initial_owner field pending_owner: ByStr20 = zero_address field total_supply : Uint128 = init_supply field balances: Map ByStr20 Uint128 = let emp_map = Emp ByStr20 Uint128 in builtin put emp_map initial_owner init_supply field dex_check_enabled : Bool = True field allowances: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128) field dexs : Map ByStr20 Bool = Emp ByStr20 Bool procedure ThrowError(err : Error) e = make_error err; throw e end procedure IsNotSender(address: ByStr20) is_sender = builtin eq _sender address; match is_sender with | True => err = CodeIsSender; ThrowError err | False => end end procedure AuthorizedMoveIfSufficientBalance(from: ByStr20, to: ByStr20, amount: Uint128) get_from_bal <- balances[from]; match get_from_bal with | Some bal => can_do = uint128_le amount bal; match can_do with | True => new_from_bal = builtin sub bal amount; balances[from] := new_from_bal; get_to_bal <- balances[to]; new_to_bal = match get_to_bal with | Some bal => builtin add bal amount | None => amount end; balances[to] := new_to_bal | False => err = CodeInsufficientFunds; ThrowError err end | None => err = CodeInsufficientFunds; ThrowError err end end procedure TransferPair(input_pair: Pair (ByStr20) (Uint128)) to = let fst_to = @fst ByStr20 Uint128 in fst_to input_pair; amount = let snd_amt = @snd ByStr20 Uint128 in snd_amt input_pair; AuthorizedMoveIfSufficientBalance _sender to amount; e = {_eventname : "TransferSuccess"; sender : _sender; recipient : to; amount : amount}; event e end procedure AuthorizedBatchMoveIfSufficientBalance(from: ByStr20, to_list: List (Pair (ByStr20) (Uint128)), total_amount: Uint128) get_from_bal <- balances[from]; match get_from_bal with | Some bal => can_do = uint128_le total_amount bal; match can_do with | True => forall to_list TransferPair | False => err = CodeInsufficientFunds; ThrowError err end | None => err = CodeInsufficientFunds; ThrowError err end end procedure ThrowIfDexNotFound(dex_address: ByStr20) current_dex_check_enabled <- dex_check_enabled; match current_dex_check_enabled with | True => may_be_exists <- dexs[dex_address]; match may_be_exists with | None => e = { _exception : "DEXNotFound"}; throw e | Some result => end | False => end end procedure ThrowIfDexIsActive(dex_address: ByStr20) current_dex_check_enabled <- dex_check_enabled; match current_dex_check_enabled with | True => may_be_exists <- dexs[dex_address]; match may_be_exists with | None => e = { _exception : "DEXNotFound"}; throw e | Some result => match result with | True => e = { _exception : "DEXIsActiveOperationNotAllowed"}; throw e | False => end end | False => end end procedure ThrowIfDexIsInActive(dex_address: ByStr20) current_dex_check_enabled <- dex_check_enabled; match current_dex_check_enabled with | True => may_be_exists <- dexs[dex_address]; match may_be_exists with | None => e = { _exception : "DEXNotFound"}; throw e | Some result => match result with | True => | False => e = { _exception : "DEXIsInActiveOperationNotAllowed"}; throw e end end | False => end end procedure ThrowUnlessSenderIsOwner(initiator: ByStr20) existing_owner <- owner; is_owner = builtin eq initiator existing_owner; match is_owner with | True => | False => e = { _exception : "InvalidSender"; initiator : initiator; owner : existing_owner }; throw e end end transition TransferOwnership(new_owner: ByStr20) ThrowUnlessSenderIsOwner _sender; existing_owner <- owner; new_owner_is_existing_owner = builtin eq new_owner existing_owner; match new_owner_is_existing_owner with | True => e = { _exception : "ExistingOwner" }; throw e | False => pending_owner := new_owner end end transition AcceptPendingOwnership() new_owner <- pending_owner; sender_is_pending_owner = builtin eq _sender new_owner; match sender_is_pending_owner with | False => e = { _exception : "InvalidSender" }; throw e | True => owner := new_owner; pending_owner := zero_address; e = { _eventname: "OwnershipTransferred"; owner : new_owner}; event e end end transition IncreaseAllowance(spender: ByStr20, amount: Uint128) IsNotSender spender; ThrowIfDexIsInActive spender; some_current_allowance <- allowances[_sender][spender]; current_allowance = get_val some_current_allowance; new_allowance = builtin add current_allowance amount; allowances[_sender][spender] := new_allowance; e = {_eventname : "IncreasedAllowance"; token_owner : _sender; spender: spender; new_allowance : new_allowance}; event e end transition DecreaseAllowance(spender: ByStr20, amount: Uint128) IsNotSender spender; ThrowIfDexIsInActive spender; some_current_allowance <- allowances[_sender][spender]; current_allowance = get_val some_current_allowance; new_allowance = let amount_le_allowance = uint128_le amount current_allowance in match amount_le_allowance with | True => builtin sub current_allowance amount | False => zero end; allowances[_sender][spender] := new_allowance; e = {_eventname : "DecreasedAllowance"; token_owner : _sender; spender: spender; new_allowance : new_allowance}; event e end transition Transfer(to: ByStr20, amount: Uint128) AuthorizedMoveIfSufficientBalance _sender to amount; e = {_eventname : "TransferSuccess"; sender : _sender; recipient : to; amount : amount}; event e; msg_to_recipient = {_tag : "RecipientAcceptTransfer"; _recipient : to; _amount : zero; sender : _sender; recipient : to; amount : amount}; msg_to_sender = {_tag : "TransferSuccessCallBack"; _recipient : _sender; _amount : zero; sender : _sender; recipient : to; amount : amount}; msgs = two_msgs msg_to_recipient msg_to_sender; send msgs end transition BatchTransfer( to_list: List (Pair (ByStr20) (Uint128)) ) list_unzip_amt = @list_unzip ByStr20 Uint128; list_unzipped_amt = list_unzip_amt to_list; snd_list_pair = @snd (List ByStr20) (List Uint128); list_amount = snd_list_pair list_unzipped_amt; list_total_amt = @list_total (List Uint128); total = list_total_amt list_amount; AuthorizedBatchMoveIfSufficientBalance _sender to_list total; msg_to_sender = {_tag : "BatchTransferSuccessCallBack"; _recipient : _sender; _amount : zero; sender : _sender; amount : total}; msg = one_msg msg_to_sender; send msg end transition TransferFrom(from: ByStr20, to: ByStr20, amount: Uint128) ThrowIfDexIsInActive _sender; get_spender_allowed <- allowances[from][_sender]; match get_spender_allowed with | Some allowed => can_do = uint128_le amount allowed; match can_do with | True => AuthorizedMoveIfSufficientBalance from to amount; e = {_eventname : "TransferFromSuccess"; initiator : _sender; sender : from; recipient : to; amount : amount}; event e; new_allowed = builtin sub allowed amount; allowances[from][_sender] := new_allowed; msg_to_recipient = {_tag : "RecipientAcceptTransferFrom"; _recipient : to; _amount : zero; initiator : _sender; sender : from; recipient : to; amount : amount}; msg_to_sender = {_tag : "TransferFromSuccessCallBack"; _recipient : _sender; _amount : zero; initiator : _sender; sender : from; recipient : to; amount : amount}; msgs = two_msgs msg_to_recipient msg_to_sender; send msgs | False => err = CodeInsufficientAllowance; ThrowError err end | None => err = CodeInsufficientAllowance; ThrowError err end end transition EnableDexCheck() ThrowUnlessSenderIsOwner _sender; dex_check_enabled := bool_active; e = {_eventname : "EnableDexCheck"; dex_check_enabled : bool_active}; event e end transition DisableDexCheck() ThrowUnlessSenderIsOwner _sender; dex_check_enabled := bool_inactive; e = {_eventname : "DisableDexCheck"; dex_check_enabled : bool_inactive}; event e end transition AddDex(dex_address : ByStr20) ThrowUnlessSenderIsOwner _sender; dexs[dex_address] := bool_active; msg_to_sender = {_tag : "DexAddedSuccessCallBack"; _recipient : _sender; _amount : zero; dex_address : dex_address}; msg = one_msg msg_to_sender end transition DisableDex(dex_address : ByStr20) ThrowUnlessSenderIsOwner _sender; ThrowIfDexNotFound dex_address; dexs[dex_address] := bool_inactive; msg_to_sender = {_tag : "DexDisabledSuccessCallBack"; _recipient : _sender; _amount : zero; dex_address : dex_address}; msg = one_msg msg_to_sender end transition RemoveDex(dex_address : ByStr20) ThrowUnlessSenderIsOwner _sender; ThrowIfDexIsActive dex_address; delete dexs[dex_address]; msg_to_sender = {_tag : "DexRemovedSuccessCallBack"; _recipient : _sender; _amount : zero; dex_address : dex_address}; msg = one_msg msg_to_sender end 